* 내림차순
Arrays.sort(arr, Collections.reverseOrder()); > Integer 타입

* 우선순위 큐 조건
1차원일 때
PriorityQueue<Integer> pq = new PriorityQueue<>();
PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());

2차원 배열일 때
PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> {
    // o1과 o2는 큐에 들어있는 각각의 int[] 배열입니다.
    

    return o1[0] - o2[0]; // 첫 번째 숫자 기준 오름차순
    // return o2[0] - o1[0]; // 첫 번째 숫자 기준 내림차순
});


* 2차원 배열 돌리기
(r,c) -> c, N-1-r N은 행갯수

*map 정렬
map.entrySet().stream().sorted(Map.Entry.comparingByValue()).mapToInt(Map.Entry::getValue).toArray();

* dfs
 public int dfs(int[] numbers, int target, int sum, int idx) {
        int count = 0;
        if (idx >= numbers.length) {
            if(sum == target) return 1;
            else return 0;
        }

        count += dfs(numbers, target, sum + numbers[idx], idx + 1);
        count += dfs(numbers, target, sum - numbers[idx], idx + 1);
        
        return count;

    }

 while(!q.isEmpty()) {
            int[] cur = q.poll();
            int cy = cur[0];
            int cx = cur[1];
            answer = cur[2];
            if(cy == maps.length-1 && cx == maps[0].length-1) {
                return answer;
            }

            for(int i=0; i<4; i++) {
                int ny = cy + dy[i];
                int nx = cx + dx[i];
                if (ny >= 0 && nx >= 0 && ny < maps.length && nx < maps[0].length) {
                    if(maps[ny][nx] == 1) {
                        maps[ny][nx] = 9;
                        q.add(new int[]{ny, nx, answer + 1});
                    }
                }
            }
        }

* 2진수 변환
Integer.toBinaryString(int a);


* Character 숫자를 int로 계산하기
String.valueOf()로 감싸기 (추천): Integer.parseInt(String.valueOf(strN.charAt(i)))
문자 빼기: strN.charAt(i) - '0' (가장 빠르고 효율적)

* 유클리드 호제법 (최대공약수 구하기)
21 12
a = 12
r = 9
a = 9
r = 3
a = 3
r = 0
int gcd(int a, int b) {
    while(b!=0) {
        int r = a % b;
        a = b;
        b = r;
    }

    return a;
}